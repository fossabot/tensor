General:
[  ] - `Tensor` - immutable size.
[  ] - `Tensor` - all values of the same type.
[  ] - (n, m, o) shape: n - rows, m - columns, o - depth.
[  ] - (n) vector is represented as column: (n) shape.
[  ] - () shape: scalar, rank = 0.
[  ] - () == (1) == (1, 1, ..., 1): shape.
[  ] - Tensor axis 0 is vertical, 1 - horizontal.
[  ] - Tensor zero value behaves like a scalar set to 0.
[  ] - Does not support broadcasting.
[  ] - 0 shapes in any dimensions are allowed.

Forms:
[  ] - `owner` - tensor that owns data buffer.
[  ] - `view` - "pointer" to data owner Tensor or another view.
[  ] - `delegate` property  - defines op destination buffer.

API:
  (A) - package level types.
    [  ] - type Tensor struct {...}
    [  ] - type TensorSlice []*Tensor

  (B) - package level constants.

  (C) - package level values.
    [  ] - PrintElementsThreshold = 8 // Number of printed Tensor elements.
           Negative value means unlimited.

  (D) - package level functions. They **ALWAYS** create a new Tensor. Operations
        at this level **MAY** change Tensor shape.
    [  ] - tensor.New(shape ...int) *Tensor // tensor constructor.
    [  ] - tensor.NewScalar(val complex128) *Tensor // 0-rank tensor ctor.
    [  ] - tensor.Delegate(res, src *Tensor) *Tensor // delegate src result to
           // res.
    [  ] - tensor.Comp(a, b *Tensor, comp func(a, b *Tensor) int) *Tensor
           // compare two tensors and return the result as a new one. (+)($)
    [  ] - tensor.Add(a, b *Tensor) *Tensor // return a new Tensor that stores
           a+b. (+)($)
    [  ] - tensor.Sub(a, b *Tensor) *Tensor // return a new Tensor that stores
           a-b. (+)($)
    [  ] - tensor.Mul(a, b *Tensor) *Tensor // return a new Tensor that stores
           element-wise a*b. (+)($)
    [  ] - tensor.Div(a, b *Tensor) *Tensor // return a new Tensor that stores
           element-wise a/b. (+)($)
    [  ] - tensor.Dot(a, b *Tensor) *Tensor // return a new Tensor that stores
           dot product of a and b. Tensor shapes must follow dot product dim
           rules.
    [  ] - tensor.Resize(t *Tensor, shape ...int) // return a new Tensor that
           stores copies of t - either repeated or truncated to match new shape.

  (E) - object level methods. If operation changes the Tensor, it **MUST**
        modify Tensor data buffer in place. (*)
    [ x] - t.NDim() int // rank, num dimensions, num axes.
    [ x] - t.Shape() []int // exact dimensions of tensor: len(t.Shape()) == t.NDim().
    [ x] - t.Size() int // total number of elements.
    [  ] - t.Data() []byte // data buffer. Owner buffer for views.
    [  ] - t.Owner() bool // true for `owners`.
    [  ] - t.Delegate() *Tensor // create delegate to self.
    [  ] - t.Base() *Tensor // non-nil for views.
    [  ] - t.Reshape(shape ...int) *Tensor // reshape tensor. Panics if (*).
    [  ] - t.FillBuf(data []byte) *Tensor // set data buffer. Panics if not
          `owner`.
    [  ] - t.Each(f func(t *Tensor)) *Tensor // iterates over each element.
    [  ] - t.Zeros() *Tensor // fill with 0 values.
    [  ] - t.Ones() *Tensor // fill with 1 values.
    [  ] - t.Arange(start, step complex128) *Tensor // fill from start to end
           increasing by step.
    [  ] - t.Linspace(start, end complex128) *Tensor // fill from start to end
           increasing by constant step.
    [  ] - t.Pow(v complex128) *Tensor // store element-wise t^v in t and return t.
    [  ] - t.Sqrt() *Tensor // store element-wise t^0.5 in t and return t.
    [  ] - t.Sin() *Tensor // store element-wise sin(t) in t and return t.
    [  ] - t.Exp() *Tensor // store element-wise e^t in t and return t.
    [  ] - t.String() string // display formatted tensor. First dimension is
           horizontal. Non ASCII characters are not used.
    [  ] - t.Copy() *Tensor // create a copy of t. Return value is the `owner`.
    [  ] - t.Comp(u *Tensor, comp func(a, b *Tensor) int) *Tensor //
           compare with u tensor and store the result in t. (+)($)
    [ x] - t.Add(u *Tensor) *Tensor // element-wise t+u -> t and return t. (+)($)
    [  ] - t.Sub(u *Tensor) *Tensor // element-wise t-u -> t and return t. (+)($)
    [  ] - t.Mul(u *Tensor) *Tensor // element-wise t*u -> t and return t. (+)($)
    [  ] - t.Div(u *Tensor) *Tensor // element-wise t/u -> t and return t. (+)($)
    [  ] - t.Dot(u *Tensor) *Tensor // dot product of t (o) u -> t return t. (^)
    [  ] - t.Sum() *Tensor // sum of all tensor elements. (+)
    [  ] - t.Max() *Tensor // minimum of all tensor elements. (+)
    [  ] - t.Min() *Tensor // maximum of all tensor elements. (+)
    [  ] - t.CumSum() *Tensor // cumulative sum of all tensor elements. (+)
    [  ] - t.Ravel() *Tensor // flatten tensor to 1 dim with t.Size() size.
    [  ] - t.Random(source rand.Source) *Tensor // fill t with random values.
    [  ] - t.Re() *Tensor // remove imaginary part from tensor.
    [  ] - t.Im() *Tensor // remove real part from tensor.
    [  ] - t.T() *Tensor // transpose t. (+)
    [  ] - t.Inv() *Tensor // inverse t^(-1) of t. (#)(+)
    [  ] - t.Eye() *Tensor // 1s on diagonal, 0s elsewhere. (+)
    [  ] - t.Trace() *Tensor // sum diag elements. (+)
    [  ] - t.At(idx ...int) *Tensor // get scalar from tensor index. (+)

  (F) - views creation methods. They **MUST NOT** modify called Tensor. Instead,
        they **MUST** return Tensor view or a slice of Tensor views. Views
        **MUST** be supported by function from (D), (E), (F).
    [  ] - t.View() *Tensor // crate a view of entire t.
    [  ] - t.Slice(dim, from int, to ...int) *Tensor // create a view over a
           subset of t.
    [  ] - t.Destruct() TensorSlice // create a view on each element.
    [  ] - t.Split(dim int) TensorSlice // split along given axis.

  (G) - tensor slice methods. They **MUST** return a new tensor or fill
        delegated one.
    [  ] - ts.VStack() *Tensor // stack tensors along their first axis.
    [  ] - ts.HStack() *Tensor // stack tensors along their second axis.

  (*) - operation **MUST NOT** change Tensor size.
  (+) - operation **MUST** support scalars.
  ($) - operation **MUST** panic when tensors have different shape.
  (^) - tensor shapes and dimensions **MUST** be equal.
  (#) - tensor must be squared.

Multitype feature:
[  ] - dtype package: custom type instead of complex128.
  (A) - package level types.
    [  ] - type DType uint
    [  ] - type Value interface{}

  (B) - package level constants.
    [  ] - Invalid DType = 0  // 0 bytes.
    [  ] - Bool DType    = 1  // 1 byte signed.
    [  ] - Byte DType    = 2  // 1 byte unsigned.
    [  ] - Int32 DType   = 3  // 4 byte signed.
    [  ] - Int64 DType   = 4  // 8 byte signed.
    [  ] - UInt32 DType  = 5  // 4 byte unsigned.
    [  ] - UInt64 DType  = 6  // 8 byte unsigned.
    [  ] - Float32 DType = 7  // 4 bytes.
    [  ] - Float64 DType = 8  // 8 bytes.
    [  ] - Cmplx DType   = 9  // 16 bytes.
    [  ] - String DType  = 10 // ? bytes.
    [  ] - Object DType  = 11 // ? bytes.

  (E) - object level methods.
    [  ] - t.AsType(k DType) // convert Tensor internal data type.
    [  ] - t.Bool() bool // get t as boolean value. (@)
    [  ] - t.Byte() byte // get t to byte value. (@)
    [  ] - t.Int() int // get t to signed 64-bit integer. (@)
    [  ] - t.Float() float64 // get t to std 32-bit floating point. (@)
    [  ] - t.Cmplx() complex128 // get t to 128-bit complex value. (@)
    [  ] - t.String() string // get t to string value.
    [  ] - t.Object() interface{} // get t as Go empty interface. (@)

  (@) - tensor **MUST** be 0 rank (scalar).

Future features:
[  ] - txtfmt package: custom display options for I/O formatting.
[  ] - broadcasting for package level functions.
[  ] - masks.