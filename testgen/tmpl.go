package main

import "text/template"

var tmpl = template.Must(template.New("").Funcs(funcMap).Parse(`// Code generated by testgen; DO NOT EDIT.

package tensor_test

import (
	"reflect"
	"testing"

	"github.com/ppknap/tensor"
	"github.com/ppknap/tensor/dtype"

	"github.com/ppknap/tensor/internal/core"
)

// Use reflect, core, and dtype packages in case they aren't used in tests.
var _ = reflect.TypeOf(dtype.DType(0) == core.DType(0)){{ range . }}{{ if .Pass }}

func TestTensor{{ .Name }}(t *testing.T) {
	tests := map[string]struct {
		Got, Want {{ .RTyp }}
	}{ {{- range .Pass }}
		"{{ .Name }}": {
			Got:  {{ .Expr }},
			Want: {{ .Want }},
		},{{ end }}
	}

	for name, test := range tests {
		t.Run(name, func(t *testing.T) {
			{{ if .Nillable }}if test.Want == nil && test.Got == nil {
				return
			}

			if test.Want == nil && test.Got != nil {
				t.Fatalf("want result to be nil, got %v", test.Got)
			}
			if test.Want != nil && test.Got == nil {
				t.Fatalf("want result to be not nil")
			}
			{{ end }}{{ range $expr, $msg := makeComparators .RTyp }}if {{ $expr }} {
				t.Errorf({{ $msg }})
			}{{ end }}
		})
	}
}{{ end }}{{ if .Panic }}

func TestTensorPanic{{ .Name }}(t *testing.T) {
	tests := map[string]func() {
		{{- range .Panic }}
		"{{ .Name }}": func() { _ = {{ .Expr }} },{{ end }}
	}

	for name, fn := range tests {
		t.Run(name, func(t *testing.T) {
			defer func() {
				if e, ok := recover().(*core.Error); !ok || e == nil {
					t.Fatalf("test should have panicked with Error, but it did not")
				}
			}()

			fn()
		})
	}
}{{ end }}{{ end }}
`))

var funcMap = template.FuncMap{
	// makeComparators creates a testing expressions based on tested type.
	"makeComparators": func(t string) map[string]string {
		switch t {
		case "bool", "byte", "int", "float64", "complex128", "string", "dtype.DType":
			return map[string]string{
				"test.Want != test.Got": `"want %v; got %v", test.Want, test.Got`,
			}
		case "*tensor.Tensor":
			return map[string]string{
				"ws, ts := test.Want.Shape(), test.Got.Shape(); !reflect.DeepEqual(ws, ts)": `"want shape=%v; got %v", ws, ts`,
			}
		default:
			return map[string]string{
				"!reflect.DeepEqual(test.Want, test.Got)": `"want %v; got %v", test.Want, test.Got`,
			}
		}
	},
}
