// Code generated by testgen; DO NOT EDIT.

package tensor_test

import (
	"reflect"
	"testing"

	"github.com/ppknap/tensor"
	"github.com/ppknap/tensor/dtype"

	"github.com/ppknap/tensor/internal/core"
)

// Use reflect, core, and dtype packages in case they aren't used in tests.
var _ = reflect.TypeOf(dtype.DType(0) == core.DType(0))

func TestTensorCopy(t *testing.T) {
	tests := map[string]struct {
		Got, Want *tensor.Tensor
	}{
		"zero value": {
			Got:  (&tensor.Tensor{}).Copy(),
			Want: tensor.New(),
		},
		"new empty tensor aka scalar": {
			Got:  tensor.New().Copy(),
			Want: tensor.New(),
		},
		"vector with one element": {
			Got:  enumerate(tensor.New(1)).Copy(),
			Want: tensor.New(1),
		},
		"vector with 9 elements": {
			Got:  enumerate(tensor.New(9)).Copy(),
			Want: tensor.New(9),
		},
		"matrix one element": {
			Got:  enumerate(tensor.New(1, 1)).Copy(),
			Want: tensor.New(1, 1),
		},
		"square matrix": {
			Got:  enumerate(tensor.New(3, 3)).Copy(),
			Want: tensor.New(3, 3),
		},
		"square matrix view": {
			Got:  enumerate(tensor.New(3, 3).View()).Copy(),
			Want: tensor.New(3, 3),
		},
		"matrix three rows two cols": {
			Got:  enumerate(tensor.New(3, 2)).Copy(),
			Want: tensor.New(3, 2),
		},
		"three dim tensor": {
			Got:  enumerate(tensor.New(4, 3, 2)).Copy(),
			Want: tensor.New(4, 3, 2),
		},
		"six dim tensor one element": {
			Got:  enumerate(tensor.New(1, 1, 1, 1, 1, 1)).Copy(),
			Want: tensor.New(1, 1, 1, 1, 1, 1),
		},
	}

	for name, test := range tests {
		t.Run(name, func(t *testing.T) {
			if test.Want == nil && test.Got == nil {
				return
			}

			if test.Want == nil && test.Got != nil {
				t.Fatalf("want result to be nil, got %v", test.Got)
			}
			if test.Want != nil && test.Got == nil {
				t.Fatalf("want result to be not nil")
			}
			if ws, ts := test.Want.Shape(), test.Got.Shape(); !reflect.DeepEqual(ws, ts) {
				t.Errorf("want shape=%v; got %v", ws, ts)
			}
		})
	}
}

func TestTensorView(t *testing.T) {
	tests := map[string]struct {
		Got, Want *tensor.Tensor
	}{
		"zero value": {
			Got:  (&tensor.Tensor{}).View(),
			Want: tensor.New(),
		},
		"new empty tensor aka scalar": {
			Got:  tensor.New().View(),
			Want: tensor.New(),
		},
		"vector with one element": {
			Got:  enumerate(tensor.New(1)).View(),
			Want: tensor.New(1),
		},
		"vector with 9 elements": {
			Got:  enumerate(tensor.New(9)).View(),
			Want: tensor.New(9),
		},
		"matrix one element": {
			Got:  enumerate(tensor.New(1, 1)).View(),
			Want: tensor.New(1, 1),
		},
		"square matrix": {
			Got:  enumerate(tensor.New(3, 3)).View(),
			Want: tensor.New(3, 3),
		},
		"square matrix view": {
			Got:  enumerate(tensor.New(3, 3).View()).View(),
			Want: tensor.New(3, 3),
		},
		"matrix three rows two cols": {
			Got:  enumerate(tensor.New(3, 2)).View(),
			Want: tensor.New(3, 2),
		},
		"three dim tensor": {
			Got:  enumerate(tensor.New(4, 3, 2)).View(),
			Want: tensor.New(4, 3, 2),
		},
		"six dim tensor one element": {
			Got:  enumerate(tensor.New(1, 1, 1, 1, 1, 1)).View(),
			Want: tensor.New(1, 1, 1, 1, 1, 1),
		},
	}

	for name, test := range tests {
		t.Run(name, func(t *testing.T) {
			if test.Want == nil && test.Got == nil {
				return
			}

			if test.Want == nil && test.Got != nil {
				t.Fatalf("want result to be nil, got %v", test.Got)
			}
			if test.Want != nil && test.Got == nil {
				t.Fatalf("want result to be not nil")
			}
			if ws, ts := test.Want.Shape(), test.Got.Shape(); !reflect.DeepEqual(ws, ts) {
				t.Errorf("want shape=%v; got %v", ws, ts)
			}
		})
	}
}

func TestTensorAsType(t *testing.T) {
	tests := map[string]struct {
		Got, Want *tensor.Tensor
	}{
		"zero value": {
			Got:  (&tensor.Tensor{}).AsType(dtype.String),
			Want: tensor.New(),
		},
		"new empty tensor aka scalar": {
			Got:  tensor.New().AsType(dtype.String),
			Want: tensor.New(),
		},
		"vector with one element": {
			Got:  enumerate(tensor.New(1)).AsType(dtype.String),
			Want: tensor.New(1),
		},
		"vector with 9 elements": {
			Got:  enumerate(tensor.New(9)).AsType(dtype.String),
			Want: tensor.New(9),
		},
		"matrix one element": {
			Got:  enumerate(tensor.New(1, 1)).AsType(dtype.String),
			Want: tensor.New(1, 1),
		},
		"square matrix": {
			Got:  enumerate(tensor.New(3, 3)).AsType(dtype.String),
			Want: tensor.New(3, 3),
		},
		"square matrix view": {
			Got:  enumerate(tensor.New(3, 3).View()).AsType(dtype.String),
			Want: tensor.New(3, 3),
		},
		"matrix three rows two cols": {
			Got:  enumerate(tensor.New(3, 2)).AsType(dtype.String),
			Want: tensor.New(3, 2),
		},
		"three dim tensor": {
			Got:  enumerate(tensor.New(4, 3, 2)).AsType(dtype.String),
			Want: tensor.New(4, 3, 2),
		},
		"six dim tensor one element": {
			Got:  enumerate(tensor.New(1, 1, 1, 1, 1, 1)).AsType(dtype.String),
			Want: tensor.New(1, 1, 1, 1, 1, 1),
		},
	}

	for name, test := range tests {
		t.Run(name, func(t *testing.T) {
			if test.Want == nil && test.Got == nil {
				return
			}

			if test.Want == nil && test.Got != nil {
				t.Fatalf("want result to be nil, got %v", test.Got)
			}
			if test.Want != nil && test.Got == nil {
				t.Fatalf("want result to be not nil")
			}
			if ws, ts := test.Want.Shape(), test.Got.Shape(); !reflect.DeepEqual(ws, ts) {
				t.Errorf("want shape=%v; got %v", ws, ts)
			}
		})
	}
}

func TestTensorBool(t *testing.T) {
	tests := map[string]struct {
		Got, Want bool
	}{
		"zero value": {
			Got:  (&tensor.Tensor{}).Bool(),
			Want: false,
		},
		"new empty tensor aka scalar": {
			Got:  tensor.New().Bool(),
			Want: false,
		},
		"vector with one element": {
			Got:  enumerate(tensor.New(1)).Bool(),
			Want: false,
		},
		"matrix one element": {
			Got:  enumerate(tensor.New(1, 1)).Bool(),
			Want: false,
		},
		"six dim tensor one element": {
			Got:  enumerate(tensor.New(1, 1, 1, 1, 1, 1)).Bool(),
			Want: false,
		},
	}

	for name, test := range tests {
		t.Run(name, func(t *testing.T) {
			if test.Want != test.Got {
				t.Errorf("want %v; got %v", test.Want, test.Got)
			}
		})
	}
}

func TestTensorPanicBool(t *testing.T) {
	tests := map[string]func(){
		"vector with 9 elements":     func() { _ = enumerate(tensor.New(9)).Bool() },
		"square matrix":              func() { _ = enumerate(tensor.New(3, 3)).Bool() },
		"square matrix view":         func() { _ = enumerate(tensor.New(3, 3).View()).Bool() },
		"matrix three rows two cols": func() { _ = enumerate(tensor.New(3, 2)).Bool() },
		"three dim tensor":           func() { _ = enumerate(tensor.New(4, 3, 2)).Bool() },
	}

	for name, fn := range tests {
		t.Run(name, func(t *testing.T) {
			defer func() {
				if e, ok := recover().(*core.Error); !ok || e == nil {
					t.Fatalf("test should have panicked with Error, but it did not")
				}
			}()

			fn()
		})
	}
}

func TestTensorByte(t *testing.T) {
	tests := map[string]struct {
		Got, Want byte
	}{
		"zero value": {
			Got:  (&tensor.Tensor{}).Byte(),
			Want: 0,
		},
		"new empty tensor aka scalar": {
			Got:  tensor.New().Byte(),
			Want: 0,
		},
		"vector with one element": {
			Got:  enumerate(tensor.New(1)).Byte(),
			Want: 0,
		},
		"matrix one element": {
			Got:  enumerate(tensor.New(1, 1)).Byte(),
			Want: 0,
		},
		"six dim tensor one element": {
			Got:  enumerate(tensor.New(1, 1, 1, 1, 1, 1)).Byte(),
			Want: 0,
		},
	}

	for name, test := range tests {
		t.Run(name, func(t *testing.T) {
			if test.Want != test.Got {
				t.Errorf("want %v; got %v", test.Want, test.Got)
			}
		})
	}
}

func TestTensorPanicByte(t *testing.T) {
	tests := map[string]func(){
		"vector with 9 elements":     func() { _ = enumerate(tensor.New(9)).Byte() },
		"square matrix":              func() { _ = enumerate(tensor.New(3, 3)).Byte() },
		"square matrix view":         func() { _ = enumerate(tensor.New(3, 3).View()).Byte() },
		"matrix three rows two cols": func() { _ = enumerate(tensor.New(3, 2)).Byte() },
		"three dim tensor":           func() { _ = enumerate(tensor.New(4, 3, 2)).Byte() },
	}

	for name, fn := range tests {
		t.Run(name, func(t *testing.T) {
			defer func() {
				if e, ok := recover().(*core.Error); !ok || e == nil {
					t.Fatalf("test should have panicked with Error, but it did not")
				}
			}()

			fn()
		})
	}
}

func TestTensorInt(t *testing.T) {
	tests := map[string]struct {
		Got, Want int
	}{
		"zero value": {
			Got:  (&tensor.Tensor{}).Int(),
			Want: 0,
		},
		"new empty tensor aka scalar": {
			Got:  tensor.New().Int(),
			Want: 0,
		},
		"vector with one element": {
			Got:  enumerate(tensor.New(1)).Int(),
			Want: 0,
		},
		"matrix one element": {
			Got:  enumerate(tensor.New(1, 1)).Int(),
			Want: 0,
		},
		"six dim tensor one element": {
			Got:  enumerate(tensor.New(1, 1, 1, 1, 1, 1)).Int(),
			Want: 0,
		},
	}

	for name, test := range tests {
		t.Run(name, func(t *testing.T) {
			if test.Want != test.Got {
				t.Errorf("want %v; got %v", test.Want, test.Got)
			}
		})
	}
}

func TestTensorPanicInt(t *testing.T) {
	tests := map[string]func(){
		"vector with 9 elements":     func() { _ = enumerate(tensor.New(9)).Int() },
		"square matrix":              func() { _ = enumerate(tensor.New(3, 3)).Int() },
		"square matrix view":         func() { _ = enumerate(tensor.New(3, 3).View()).Int() },
		"matrix three rows two cols": func() { _ = enumerate(tensor.New(3, 2)).Int() },
		"three dim tensor":           func() { _ = enumerate(tensor.New(4, 3, 2)).Int() },
	}

	for name, fn := range tests {
		t.Run(name, func(t *testing.T) {
			defer func() {
				if e, ok := recover().(*core.Error); !ok || e == nil {
					t.Fatalf("test should have panicked with Error, but it did not")
				}
			}()

			fn()
		})
	}
}

func TestTensorFloat(t *testing.T) {
	tests := map[string]struct {
		Got, Want float64
	}{
		"zero value": {
			Got:  (&tensor.Tensor{}).Float(),
			Want: 0,
		},
		"new empty tensor aka scalar": {
			Got:  tensor.New().Float(),
			Want: 0,
		},
		"vector with one element": {
			Got:  enumerate(tensor.New(1)).Float(),
			Want: 0,
		},
		"matrix one element": {
			Got:  enumerate(tensor.New(1, 1)).Float(),
			Want: 0,
		},
		"six dim tensor one element": {
			Got:  enumerate(tensor.New(1, 1, 1, 1, 1, 1)).Float(),
			Want: 0,
		},
	}

	for name, test := range tests {
		t.Run(name, func(t *testing.T) {
			if test.Want != test.Got {
				t.Errorf("want %v; got %v", test.Want, test.Got)
			}
		})
	}
}

func TestTensorPanicFloat(t *testing.T) {
	tests := map[string]func(){
		"vector with 9 elements":     func() { _ = enumerate(tensor.New(9)).Float() },
		"square matrix":              func() { _ = enumerate(tensor.New(3, 3)).Float() },
		"square matrix view":         func() { _ = enumerate(tensor.New(3, 3).View()).Float() },
		"matrix three rows two cols": func() { _ = enumerate(tensor.New(3, 2)).Float() },
		"three dim tensor":           func() { _ = enumerate(tensor.New(4, 3, 2)).Float() },
	}

	for name, fn := range tests {
		t.Run(name, func(t *testing.T) {
			defer func() {
				if e, ok := recover().(*core.Error); !ok || e == nil {
					t.Fatalf("test should have panicked with Error, but it did not")
				}
			}()

			fn()
		})
	}
}

func TestTensorCmplx(t *testing.T) {
	tests := map[string]struct {
		Got, Want complex128
	}{
		"zero value": {
			Got:  (&tensor.Tensor{}).Cmplx(),
			Want: 0i,
		},
		"new empty tensor aka scalar": {
			Got:  tensor.New().Cmplx(),
			Want: 0i,
		},
		"vector with one element": {
			Got:  enumerate(tensor.New(1)).Cmplx(),
			Want: 0i,
		},
		"matrix one element": {
			Got:  enumerate(tensor.New(1, 1)).Cmplx(),
			Want: 0i,
		},
		"six dim tensor one element": {
			Got:  enumerate(tensor.New(1, 1, 1, 1, 1, 1)).Cmplx(),
			Want: 0i,
		},
	}

	for name, test := range tests {
		t.Run(name, func(t *testing.T) {
			if test.Want != test.Got {
				t.Errorf("want %v; got %v", test.Want, test.Got)
			}
		})
	}
}

func TestTensorPanicCmplx(t *testing.T) {
	tests := map[string]func(){
		"vector with 9 elements":     func() { _ = enumerate(tensor.New(9)).Cmplx() },
		"square matrix":              func() { _ = enumerate(tensor.New(3, 3)).Cmplx() },
		"square matrix view":         func() { _ = enumerate(tensor.New(3, 3).View()).Cmplx() },
		"matrix three rows two cols": func() { _ = enumerate(tensor.New(3, 2)).Cmplx() },
		"three dim tensor":           func() { _ = enumerate(tensor.New(4, 3, 2)).Cmplx() },
	}

	for name, fn := range tests {
		t.Run(name, func(t *testing.T) {
			defer func() {
				if e, ok := recover().(*core.Error); !ok || e == nil {
					t.Fatalf("test should have panicked with Error, but it did not")
				}
			}()

			fn()
		})
	}
}
